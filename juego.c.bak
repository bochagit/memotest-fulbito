/**
 * @file juego.c
 * @brief Implementacion del modulo 'juego'.
 */

#include "juego.h"
#include "graficos.h"
#include "texto.h"
#include "imagenes.h"
#include "presentacion.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define TAM_BUFFER 128
#define NOTA_LA4 440.0f
#define CONTADOR_HUD_POSX_INI 148
#define CONTADOR_HUD_POSY_INI 64
#define TEXTO_POSX_INI 85
#define TEXTO_POSY_INI 680

const uint8_t sonrisa[PIXELES_X_LADO][PIXELES_X_LADO] = {
    {T, T, T, A, A, A, A, A, A, T, T, T},
    {T, T, A, A, A, A, A, A, A, A, T, T},
    {T, A, A, T, A, A, A, A, T, A, A, T},
    {A, A, A, T, A, A, A, A, T, A, A, A},
    {A, A, A, A, A, A, A, A, A, A, A, A},
    {A, A, A, A, A, A, A, A, A, A, A, A},
    {A, A, A, A, A, A, A, A, A, A, A, A},
    {A, A, T, A, A, A, A, A, A, T, A, A},
    {A, A, T, A, A, A, A, A, A, T, A, A},
    {T, A, A, T, T, T, T, T, T, A, A, T},
    {T, T, A, A, A, A, A, A, A, A, T, T},
    {T, T, T, A, A, A, A, A, A, T, T, T}
};

const uint8_t crab[PIXELES_X_LADO][PIXELES_X_LADO] = {
    {T, T, T, T, T, T, T, T, T, T, T, T},
    {T, T, T, T, T, T, T, T, T, T, T, T},
    {T, T, R, T, T, T, T, T, R, T, T, T},
    {T, T, T, R, T, T, T, R, T, T, T, T},
    {T, T, R, R, R, R, R, R, R, T, T, T},
    {T, R, R, T, R, R, R, T, R, R, T, T},
    {R, R, R, R, R, R, R, R, R, R, R, T},
    {R, T, R, R, R, R, R, R, R, T, R, T},
    {R, T, R, T, T, T, T, T, R, T, R, T},
    {T, T, T, R, R, T, R, R, T, T, T, T},
    {T, T, T, T, T, T, T, T, T, T, T, T},
    {T, T, T, T, T, T, T, T, T, T, T, T}
};

/************************
    FUNCIONES PRIVADAS
*************************/

static tError _procesar_click_izquierdo(tJuego *juego, int32_t x, int32_t y)
{
    tError err;
    int32_t offsetX = rand() % TAM_GRILLA;
    int32_t offsetY = rand() % TAM_GRILLA;

    err = hud_actualizar_dato(juego->contadorClics, &(int32_t){1});

    if (juego->audioInicializado) {
        sonidos_reproducir(juego->tono, 1);
    }

    graficos_cambiar_framebuffer(juego->renderer, juego->framebuffers[FB_ESCENA]);
    graficos_dibujar(juego->renderer, rand() & 1 ? sonrisa : crab, offsetX, offsetY);
    graficos_cambiar_framebuffer(juego->renderer, NULL);

    printf("Hiciste clic izquierdo en (%d, %d) poniendo un dibujo en la posicion aleatoria [%d,%d]\n", x, y, offsetX, offsetY);

    return err;
}

static tError _procesar_click_derecho(tJuego *juego, int32_t x, int32_t y)
{
    tError err;
    SDL_Color color = {
        .r = rand() % 256,
        .g = rand() % 256,
        .b = rand() % 256,
        .a = rand() % 64,
    };

    err = hud_actualizar_dato(juego->contadorClics, &(int32_t){-1});

    if (juego->audioInicializado) {
        sonidos_reproducir(juego->sonido, 1);
    }

    graficos_cambiar_framebuffer(juego->renderer, juego->framebuffers[FB_ESCENA]);
    graficos_borrar_pantalla(juego->renderer, &color);
    graficos_cambiar_framebuffer(juego->renderer, NULL);

    printf("Hiciste clic derecho en (%d, %d) borrando la escena\n", x, y);

    return err;
}

static tError _procesar_teclas(tJuego *juego, SDL_Keycode tecla)
{
    int8_t indice = juego->fantasmaActual;

    switch (tecla) {
        case SDLK_LEFT:
            indice--;
            if (indice < 0) {
                indice = FANTASMA_CANT - 1;
            }
            break;
        case SDLK_RIGHT:
            indice++;
            if (indice >= FANTASMA_CANT) {
                indice = 0;
            }
            break;
    }

    juego->fantasmaActual = (uint8_t)indice;

    return hud_actualizar_dato(juego->indicador, juego->fantasmas[indice]);
}

static SDL_Texture* _hud_callback_actualizar_contador (SDL_Renderer *renderer, void *dato, void *nuevoDato, void *extra)
{
    int32_t nuevoValor = *(int32_t*)dato + *(int32_t*)nuevoDato;
    uint32_t largo = snprintf(NULL, 0, "Clics: %d", nuevoValor);

    memcpy(dato, &nuevoValor, sizeof(int32_t));

    char *buffer = malloc((size_t)largo + 1);
    if (!buffer) {
        return NULL;
    }

    snprintf(buffer, largo + 1, "Clics: %d", nuevoValor);

    SDL_Texture *nuevaTextura = texto_crear_textura(renderer, extra, buffer, (SDL_Color){255, 255, 255, 255});
    free(buffer);

    return nuevaTextura;
}

static SDL_Texture* _hud_callback_actualizar_indicador (SDL_Renderer *renderer, void *dato, void *nuevoDato, void *extra)
{
    return SDL_CreateTextureFromSurface(renderer, (SDL_Surface*)nuevoDato);
}



/************************
    FUNCIONES PUBLICAS
*************************/

tError juego_inicializar(tJuego *juego)
{
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != TODO_OK) {
        fprintf(stderr, "%s\n", SDL_GetError());
        return ERR_SDL;
    }

    tError err;
    char nombreVentana[TAM_BUFFER];
    sprintf(nombreVentana, "Ejemplo Avanzado de SDL2 %dx%d",TAM_GRILLA,TAM_GRILLA);
    juego->anchoVentana = TAM_GRILLA * TAM_PIXEL * PIXELES_X_LADO  + TAM_GRILLA * PX_PADDING;
    juego->altoVentana = juego->anchoVentana;

    // Crea la ventana del juego
    juego->ventana = SDL_CreateWindow(nombreVentana,
                                           SDL_WINDOWPOS_CENTERED,
                                           SDL_WINDOWPOS_CENTERED,
                                           juego->anchoVentana,
                                           juego->altoVentana,
                                           SDL_WINDOW_SHOWN);
    if (!juego->ventana) {
        fprintf(stderr, "%s\n", SDL_GetError());
        return ERR_SDL;
    }

    // Crea el renderer para la ventana
    juego->renderer = SDL_CreateRenderer(juego->ventana, -1, SDL_RENDERER_ACCELERATED);
    if (!juego->renderer) {
        fprintf(stderr, "%s\n", SDL_GetError());
        return ERR_SDL;
    }
    SDL_SetRenderDrawBlendMode(juego->renderer, SDL_BLENDMODE_BLEND); // Habilita la transparencia en el renderer

    // Inicializa SDL_mixer
    tFormatosSnd formatosSnd = sonidos_inicializar();
    if (formatosSnd != SONIDO_ERR) {
        juego->audioInicializado = 1;

        juego->sonido = sonidos_cargar("snd/sonido.wav");
        juego->melodia = sonidos_cargar("snd/melodia.mp3");
        juego->tono = sonidos_crear_tono(NOTA_LA4);

        if (!juego->sonido || !juego->melodia  || !juego->tono) {

            fprintf(stderr, "Assets de audio no encontrados\n");
            juego->audioInicializado = 0;
            sonidos_finalizar();
        }
    } else {
        juego->audioInicializado = 0;
    }

    // Inicializa SDL_ttf
    if ((err = texto_inicializar()) != TODO_OK) {
        return err;
    }
    juego->fuenteTTF = texto_cargar_fuente("fnt/IBMPlexMono-Regular.ttf", 48);

    // Inicializa SDL_image
    if ((err = imagenes_inicializar()) != (IMAGEN_BMP | IMAGEN_JPG | IMAGEN_PNG)) {
        return err;
    }

    juego->background = imagenes_cargar_gpu(juego->renderer, "img/background.jpg");
    if (!juego->background) {
        return ERR_IMAGEN;
    }

    juego->fantasmas[FANTASMA_NARANJA] = imagenes_cargar_ram("img/pacman_fantasma_naranja.png");
    if (!juego->fantasmas[FANTASMA_NARANJA]) {
        return ERR_IMAGEN;
    }

    juego->fantasmas[FANTASMA_VERDE] = imagenes_cargar_ram("img/pacman_fantasma_verde.png");
    if (!juego->fantasmas[FANTASMA_VERDE]) {
        return ERR_IMAGEN;
    }

    juego->fantasmas[FANTASMA_ROSA] = imagenes_cargar_ram("img/pacman_fantasma_rosa.png");
    if (!juego->fantasmas[FANTASMA_ROSA]) {
        return ERR_IMAGEN;
    }

    juego->fantasmas[FANTASMA_ROJO] = imagenes_cargar_ram("img/pacman_fantasma_rojo.png");
    if (!juego->fantasmas[FANTASMA_ROJO]) {
        return ERR_IMAGEN;
    }

    juego->fantasmas[FANTASMA_AZUL] = imagenes_cargar_ram("img/pacman_fantasma_azul.png");
    if (!juego->fantasmas[FANTASMA_AZUL]) {
        return ERR_IMAGEN;
    }

    juego->fantasmaActual = FANTASMA_NARANJA;


    // Creacion del HUD
    juego->contadorClics = hud_inicializar(juego->renderer,
                                            CONTADOR_HUD_POSX_INI,
                                            CONTADOR_HUD_POSY_INI,
                                            &(int32_t){0},
                                            sizeof(int32_t),
                                            juego->fuenteTTF,
                                            _hud_callback_actualizar_contador,
                                            NULL);
    if (!juego->contadorClics) {
        return ERR_HUD_INICIALIZAR;
    }
    hud_actualizar_dato(juego->contadorClics, &(int32_t){0});

    juego->indicador = hud_inicializar(juego->renderer,
                                            juego->anchoVentana / 2,
                                            juego->altoVentana / 2,
                                            NULL,
                                            0,
                                            NULL,
                                            _hud_callback_actualizar_indicador,
                                            NULL);
    if (!juego->indicador) {
        return ERR_HUD_INICIALIZAR;
    }

    hud_actualizar_dato(juego->indicador, juego->fantasmas[FANTASMA_NARANJA]);

    juego->textoBotones = texto_crear_textura(juego->renderer, juego->fuenteTTF, "← CAMBIAR FANTASMA →", (SDL_Color){255,255,255,255});
    juego->textoBotonesCoords.x = TEXTO_POSX_INI;
    juego->textoBotonesCoords.y = TEXTO_POSY_INI;

    juego->framebuffers[FB_BACKGROUND] = graficos_crear_framebuffer(juego->renderer, juego->anchoVentana, juego->altoVentana);
    juego->framebuffers[FB_ESCENA] = graficos_crear_framebuffer(juego->renderer, juego->anchoVentana, juego->altoVentana);
    juego->framebuffers[FB_HUD] = graficos_crear_framebuffer(juego->renderer, juego->anchoVentana, juego->altoVentana);

    // Mostrar pantalla de presentación y solicitar nombre del jugador (SDL GUI)
    juego->nombreJugador[0] = '\0';
    presentacion_mostrar(juego->renderer, juego->fuenteTTF, "img/fondo_presentacion.png", "snd/Sonido_presentacion.mp3", juego->nombreJugador, sizeof(juego->nombreJugador));

    srand(time(0));
    sonidos_reproducir(juego->melodia, -1);

    // Crear la partida de memoria por defecto: 3x4, conjunto de "img/pareja", usar sonidos si están inicializados
    juego->partida = memoria_crear(juego->renderer, 3, 4, "img/pareja", juego->audioInicializado);
    if (!juego->partida) {
        // No fatal: el juego puede seguir corriendo con funcionalidades limitadas
        fprintf(stderr, "Aviso: no se pudo crear la partida de memoria.\n");
    }

    juego->corriendo = 1;
    return TODO_OK;
}


tError juego_procesar_eventos(tJuego *juego)
{
    tError err = TODO_OK;
    SDL_Event evento;

    while (SDL_PollEvent(&evento)) {

        if (evento.type == SDL_QUIT) {
            juego->corriendo = 0;
        } else if (evento.type == SDL_MOUSEBUTTONDOWN) {
            if (evento.button.button == SDL_BUTTON_LEFT) {
                if (juego->partida) {
                    memoria_procesar_evento(juego->partida, &evento);
                } else {
                    err = _procesar_click_izquierdo(juego, evento.button.x, evento.button.y);
                }
            }
            else if (evento.button.button == SDL_BUTTON_RIGHT) {
                if (!juego->partida) {
                    err = _procesar_click_derecho(juego, evento.button.x, evento.button.y);
                }
            }
        } else if (evento.type == SDL_KEYDOWN) {
            _procesar_teclas(juego, evento.key.keysym.sym);
        }
    }

    return err;
}

void juego_actualizar(tJuego *juego)
{
    static uint32_t ticks_prev = 0;
    uint32_t ticks = SDL_GetTicks();
    uint32_t delta = ticks_prev ? (ticks - ticks_prev) : LOOP_DELAY;
    ticks_prev = ticks;

    float frecuencia = ticks * 0.001f;
    int32_t movX = CONTADOR_HUD_POSX_INI + (int32_t)(sin(frecuencia) * 20.0f);
    int32_t movY = CONTADOR_HUD_POSY_INI + (int32_t)(cos(frecuencia) * 10.0f);

    juego->textoBotonesCoords.x = TEXTO_POSX_INI + (int32_t)(sin(frecuencia) * 20.0f);
    hud_actualizar_posicion_abs(juego->contadorClics, movX, movY, 0);
    hud_actualizar_posicion_rel(juego->indicador, 0, 0, 1); // Adicionamos un grado por cada frame

    // Actualizar la lógica de la partida
    if (juego->partida) {
        memoria_actualizar(juego->partida, delta);
    }
}

void juego_renderizar(tJuego *juego)
{
    // Cambiamos al framebuffer del background
    graficos_cambiar_framebuffer(juego->renderer, juego->framebuffers[FB_BACKGROUND]);
    graficos_borrar_pantalla(juego->renderer, &(SDL_Color){255,255,255,0});
    graficos_dibujar_textura(juego->renderer, juego->background, NULL, 0, 0, 1.55f, 1.55f, 0.0f, 0, 0);

    // Cambiamos al framebuffer de la escena y dejamos que la partida lo dibuje
    graficos_cambiar_framebuffer(juego->renderer, juego->framebuffers[FB_ESCENA]);
    graficos_borrar_pantalla(juego->renderer, &(SDL_Color){0,0,0,0});
    if (juego->partida) {
        memoria_renderizar(juego->partida, juego->renderer);
    }

    // Cambiamos al framebuffer del HUD para que sea dibujado por encima
    graficos_cambiar_framebuffer(juego->renderer, juego->framebuffers[FB_HUD]);
    graficos_borrar_pantalla(juego->renderer, &(SDL_Color){255,255,255,0});
    hud_dibujar(juego->contadorClics);
    hud_dibujar(juego->indicador);
    graficos_dibujar_textura(juego->renderer, juego->textoBotones, NULL, juego->textoBotonesCoords.x, juego->textoBotonesCoords.y, 1.0f, 1.0f, 0.0f, 0, 0);

    // Mostrar nombre del jugador y estadísticas simples
    if (juego->fuenteTTF) {
        char stats[128];
        int puntos=0, aciertos=0, intentos=0, racha=0;
        if (juego->partida) memoria_obtener_estadisticas(juego->partida, &puntos, &aciertos, &intentos, &racha);
        snprintf(stats, sizeof(stats), "%s  Pts:%d  Aciertos:%d  Intentos:%d  Racha:%d", juego->nombreJugador[0] ? juego->nombreJugador : "Jugador", puntos, aciertos, intentos, racha);
        SDL_Texture *tStats = texto_crear_textura(juego->renderer, juego->fuenteTTF, stats, (SDL_Color){255,255,255,255});
        if (tStats) {
            int w,h; SDL_QueryTexture(tStats, NULL, NULL, &w, &h);
            graficos_dibujar_textura(juego->renderer, tStats, NULL, 20, 20, 1.0f, 1.0f, 0.0f, 0, 0);
            SDL_DestroyTexture(tStats);
        }
    }

    // Composicion final
    graficos_renderizar(juego->renderer, juego->framebuffers, FB_CANT);
}

void juego_destruir(tJuego *juego)
{
    for (int32_t i = 0; i < FB_CANT; ++i) {
        if (juego->framebuffers[i]) {
            SDL_DestroyTexture(juego->framebuffers[i]);
        }
    }

    for (int32_t i = 0; i < FANTASMA_CANT; ++i) {
        if (juego->fantasmas[i]) {
            SDL_FreeSurface(juego->fantasmas[i]);
        }
    }

    if (juego->contadorClics) {
        hud_destruir(juego->contadorClics);
    }

    if (juego->indicador) {
        hud_destruir(juego->indicador);
    }

    if (juego->fuenteTTF) {
        texto_destruir_fuente(juego->fuenteTTF);
        if (juego->textoBotones) {
            SDL_DestroyTexture(juego->textoBotones);
        }
    }
    texto_finalizar();

    if (juego->audioInicializado) {
        sonidos_destruir(juego->sonido);
        sonidos_destruir(juego->melodia);
        sonidos_destruir(juego->tono);
        sonidos_finalizar();
    }

    if (juego->partida) {
        memoria_destruir(juego->partida);
        juego->partida = NULL;
    }

    if (juego->background) {
        SDL_DestroyTexture(juego->background);
    }
    imagenes_finalizar();

    if (juego->renderer) {
        SDL_DestroyRenderer(juego->renderer);
    }

    if (juego->ventana) {
        SDL_DestroyWindow(juego->ventana);
    }

    SDL_Quit();
}
